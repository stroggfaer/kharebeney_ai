# Промт для реализации полнофункционального метода set_prompt для управления агентом

## Цель
Реализовать полнофункциональный метод `set_prompt`, который будет действительно влиять на поведение агента Kharebeney AI, изменяя приоритеты действий, эмоциональные реакции и стратегии принятия решений на основе параметров и объектов, передаваемых через промты.

## Архитектурные требования
- Метод должен быть совместим с текущей архитектурой агента
- Не должен нарушать стабильность работы системы
- Должен учитывать текущие состояния агента при применении промтов
- Должен поддерживать как постоянные, так и временные промты
- Должен использовать параметрический подход вместо контекста пользователя

## Функциональные возможности

### 1. Влияние на систему принятия решений
- Промты должны изменять веса действий в `DecisionEngine` на основе параметров
- Промты должны учитываться при вычислении приоритетов действий в `BalanceManager`
- Промты должны интегрироваться с текущей системой приоритезации
- Промты должны использовать структурированные параметры для изменения поведения

### 2. Влияние на эмоциональную систему
- Промты могут изменять склонность к определенным эмоциям на основе параметров
- Промты могут изменять интенсивность эмоциональных реакций
- Промты могут влиять на выбор эмоционального выражения поведения

### 3. Влияние на стратегию обучения
- Промты могут изменять фокус системы обучения
- Промты могут влиять на оценку успешности действий
- Промты могут изменять приоритеты навыков в системе обучения

### 4. Режим обучения
- Поддержка включения/выключения режима обучения через промты
- Включение усиленного запоминания действий и результатов
- Увеличение приоритета обучения навыкам в игровых сценариях
- Повышенная чувствительность к положительным и отрицательным результатам действий

### 5. Временные промты
- Поддержка временных промтов с автоматическим удалением
- Поддержка приоритетных промтов, которые переопределяют обычные
- Поддержка комбинированных промтов

## Техническая реализация

### 1. Модификация метода `set_prompt`
```cpp
void KharebeneyAgent::set_prompt(const char* prompt_type, const char* content, bool temporary = false, uint32_t duration = 3600);
```
- Добавить проверку и обработку параметров в промтах
- Добавить систему приоритезации промтов
- Добавить логику интеграции с другими системами
- Добавить параметрический анализ содержимого промта

### 2. Интеграция системой принятия решений
- Модифицировать `decide_enhanced()` для учета промтов
- Добавить метод `apply_prompt_influence()` в `DecisionEngine`
- Обновить `get_action_priority()` в `BalanceManager` для учета промтов

### 3. Режим обучения
- Добавить метод `enable_learning_mode(bool enabled)` для включения/выключения режима
- Увеличить чувствительность системы обучения к результатам действий
- Повысить приоритет запоминания успешных и неудачных действий
- Добавить усиленное обучение навыкам в игровых сценариях

### 4. Обработка параметров
Система должна распознавать параметры и фразы:
- "tea", "food", "water" → изменяют параметры голода, счастья и энергии
- "social", "interact", "communicate" → увеличивают приоритет "socialize"
- "explore", "curious", "discover" → увеличивают приоритет "explore"
- "play", "fun", "happy" → увеличивают приоритет "play"
- "rest", "tired", "sleepy" → увеличивают приоритет "rest"
- "cautious", "careful", "safe" → увеличивают приоритет "heal"
- "learn", "training", "practice" → включают режим обучения

### 4. Параметрическое управление
Создать структуру данных для параметров:
```cpp
struct PromptParams {
    float hunger_change;      // Изменение голода (-1.0 до 1.0)
    float happiness_change;   // Изменение счастья (-1.0 до 1.0)
    float health_change;      // Изменение здоровья (-1.0 до 1.0)
    float energy_change;      // Изменение энергии (-1.0 до 1.0)
    float social_change;      // Изменение социальности (-1.0 до 1.0)
    float curiosity_change;   // Изменение любопытства (-1.0 до 1.0)
    float action_priority[7]; // Приоритеты действий (0.0 до 2.0)
};
```

## Примеры использования

### Сценарий 1: Взаимодействие с меню еды
```cpp
// Структура продукта
struct FoodItem {
    int id;
    std::string name;
    float hunger_satisfaction;    // Удовлетворение голода (0.0-1.0)
    float happiness_boost;       // Увеличение счастья (0.0-1.0)
    float energy_change;         // Изменение энергии (0.0-1.0)
    float health_impact;         // Влияние на здоровье (0.0-1.0)
    float social_impact;         // Влияние на социальность (0.0-1.0)
    float curiosity_impact;      // Влияние на любопытство (0.0-1.0)
};

// Пример меню
std::vector<FoodItem> menu = {
    {1001, "tea", 0.1f, 0.3f, 0.2f, 0.1f, 0.1f, 0.0f},
    {1002, "food", 0.5f, 0.2f, 0.3f, 0.2f, 0.0f, 0.0f},
    // ...
};

// Пользователь выбрал чай
FoodItem selected_item = menu[0]; // tea

// Устанавливаем промт с параметрами еды
agent->set_prompt("food_intake", selected_item.name.c_str(), true, 1800);

// Агент обрабатывает промт и обновляет внутренние состояния
agent->update_states_from_prompt(selected_item);
```

### Сценарий 2: Проверка состояния
```cpp
// Проверка, изменилось ли состояние голода после установки промта
const InternalStates* states = agent->get_internal_states();
bool hunger_satisfied = (states->hunger < 0.5f); // Агент не голоден
```

### Сценарий 3: Управление поведением
```cpp
// Установка промта для изменения поведения
agent->set_prompt("behavior", "explore", true, 1800);
// Агент начинает чаще выбирать действие "explore"
```

### Сценарий 4: Режим обучения
```cpp
// Включение режима обучения для усиленного запоминания
agent->set_prompt("learning", "enable", true, 3600);
// Агент активнее запоминает действия и результаты

// Выключение режима обучения
agent->set_prompt("learning", "disable", true, 10);
// Агент возвращается к нормальному режиму обучения
```

## Внутренняя обработка
```cpp
void KharebeneyAgent::update_states_from_prompt(const FoodItem& item) {
    // Обновляем внутренние состояния на основе параметров еды
    internal_state.perform_action("feed"); // Выполняем базовое действие
    
    // Применяем специфические изменения от еды
    InternalStates current_states = *internal_state.get_states();
    
    // Уменьшаем голод
    current_states.hunger = std::max(0.0f, current_states.hunger - item.hunger_satisfaction);
    
    // Увеличиваем счастье
    current_states.happiness = std::min(1.0f, current_states.happiness + item.happiness_boost);
    
    // Изменяем другие параметры
    current_states.energy = std::min(1.0f, current_states.energy + item.energy_change);
    current_states.health = std::min(1.0f, current_states.health + item.health_impact);
    
    // Устанавливаем обновленные состояния
    internal_state.set_states(&current_states);
}
```

## Тестирование и валидация

### 1. Диагностика влияния промтов
- Добавить в систему диагностики проверку влияния промтов
- Сравнивать поведение до и после установки промтов
- Проверять корректность сброса временных промтов

### 2. Мониторинг производительности
- Измерять дополнительную нагрузку от обработки промтов
- Проверять, что промты не нарушают стабильность системы
- Оптимизировать производительность при необходимости

## Критерии успеха

1. **Поведенческое изменение**: После установки промта агент должен изменить свое поведение
2. **Параметрическая чувствительность**: Промты должны учитывать параметры и объекты, а не контекст пользователя
3. **Временная ограниченность**: Временные промты должны автоматически удаляться
4. **Стабильность**: Система промтов не должна нарушать стабильность агента
5. **Эффективность**: Обработка промтов не должна значительно влиять на производительность

Такая реализация сделает метод `set_prompt` ключевым инструментом параметрического управления поведением агента, позволяющим адаптировать его реакции к различным ситуациям через структурированные параметры и объекты, а не через человеческий контекст.